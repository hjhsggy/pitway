## redis持久化

### RDB (Redis DataBase)

- [ ]  

### AOF (Append Only File)

- [ ] 实现方式

  - 写后日志, 类似于Mysql的binlog, 只记录执行成功的命令
  - AOF日志格式
  
  ```bash
  $ set key testdata
  ```

  ```text
  上述命令执行完, AOF日志内容如下:

    *3
    $3
    set
    $3
    key
    $8
    testdata

    *3 表示当前命令有几个部分
    $num 标识当前命令或者键值占多少字节
  ```
  

- [ ] 三种写回策略

  - AOF 配置项 appendfsync 字段三个选项

  | 策略     | 写回时机 | 优点                   | 缺点                            |
  | -------- | -------- | ---------------------- | ------------------------------- |
  | Always   | 同步写回 | 可靠性高数据基本不丢失 | 每个命令都会写入磁盘,性能影响大 |
  | Everysec | 每秒写回 | 性能适中               | 宕机时丢失一秒内的数据          |
  | No       | 操作系统 | 性能好                 | 宕机时丢失数据较多              |

  - 三种写回策略按照根据实际需要设置
    
- [ ] 常见问题

  - Q: AOF为什么要先执行再记录呢?
  - A:  
    - 传统的数据库日志, 例如redo log(重做日志文件), 记录的是修改后的数据, AOF记录的是redis收到的每一条命令
    - AOF记录的是每一条命令, 为了提高效率不会检查命令, 如果先记录再执行, 如果命令出错, redis回复数据就会有问题
    - 如果先写入后执行, 执行redis命令就会阻塞, 影响系统响应速度

  - Q: 日志文件太大怎么办?
  - A:
    - AOF记录的是每条执行的记录, 如果一个键被修改多次, 那么AOF日志也相应的要记录多次这无疑是浪费存储, 因此redis另一个机制用来减少这种重复的日志记录-AOF重写机制
    - AOF重写机制:日志是逐个追加的命令, 对于一个key只需要记录下被多个命令操作后最新状态, 将多个命令最终归结为一条命令减少日志

  - Q: AOF重写会阻塞主进程嘛? 有什么潜在风险? 
  - A: 
    - 执行AOF日志重写时, 由主进程fork出子进程 bgrewriteaof 完成日志重写
    - 主进程 fork 子进程时会阻塞主进程(fork子进程不会一次性拷贝父进程的数据, 操作系统执行的是写时复制), 整个拷贝过程需要消耗大量的CPU资源, 


  - Q: 何时触发AOF日志重写?
  - A:
    - ① 手动触发: 为了减小aof文件的体量，可以手动发送“bgrewriteaof”指令，通过子进程生成更小体积的aof，然后替换掉旧的、大体量的aof文件
    - ② 配置文件设置自动触发  
    
    ```yaml
      1）auto-aof-rewrite-percentage 100
      2）auto-aof-rewrite-min-size 64mb
      这两个配置项的意思是，在aof文件体量超过64mb，且比上次重写后的体量增加了100%时自动触发重写。我们可以修改这些参数达到自己的实际要求
    ```